# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

StabilizedScaling_Rcpp <- function(cost_matrix, supply, demand, supply_div_type, demand_div_type, supply_div_parameters, demand_div_parameters, iter_max, epsvec, tol, check_interval = 1L, indicator_slack = 1e-6, clamp = 1e100) {
    .Call('_WSGeometry_StabilizedScaling_Rcpp', PACKAGE = 'WSGeometry', cost_matrix, supply, demand, supply_div_type, demand_div_type, supply_div_parameters, demand_div_parameters, iter_max, epsvec, tol, check_interval, indicator_slack, clamp)
}

Sinkhorn_Rcpp <- function(cost_matrix, supply, demand, supply_div_type, demand_div_type, supply_div_parameters, demand_div_parameters, iter_max, epsvec, tol, thread_cnt = -1L, max_lines_per_work = 5L, indicator_slack = 1e-6) {
    .Call('_WSGeometry_Sinkhorn_Rcpp', PACKAGE = 'WSGeometry', cost_matrix, supply, demand, supply_div_type, demand_div_type, supply_div_parameters, demand_div_parameters, iter_max, epsvec, tol, thread_cnt, max_lines_per_work, indicator_slack)
}

bary_sinkhorn_arma <- function(weights, frechet, maxIter, lambda, C, thresh, threads) {
    .Call('_WSGeometry_bary_sinkhorn_arma', PACKAGE = 'WSGeometry', weights, frechet, maxIter, lambda, C, thresh, threads)
}

rand_cxx <- function() {
    .Call('_WSGeometry_rand_cxx', PACKAGE = 'WSGeometry')
}

index_cxx <- function(x, y) {
    .Call('_WSGeometry_index_cxx', PACKAGE = 'WSGeometry', x, y)
}

norm <- function(x, y) {
    .Call('_WSGeometry_norm', PACKAGE = 'WSGeometry', x, y)
}

expo <- function(a) {
    .Call('_WSGeometry_expo', PACKAGE = 'WSGeometry', a)
}

gen_cost <- function(A, B) {
    .Call('_WSGeometry_gen_cost', PACKAGE = 'WSGeometry', A, B)
}

wsbary_cxx_armaP <- function(weightsR, positions1, positionssetR, frechet_weights, fixed_support, maxIter, weights_maxIter, pos_maxIter, stepsize, thresh, headstart, headstartlength, threads) {
    .Call('_WSGeometry_wsbary_cxx_armaP', PACKAGE = 'WSGeometry', weightsR, positions1, positionssetR, frechet_weights, fixed_support, maxIter, weights_maxIter, pos_maxIter, stepsize, thresh, headstart, headstartlength, threads)
}

krbary_subgrad_cxx <- function(weightsR, costMatsR, frechet_weights, maxIter, stepsize, thresh, headstart, headstartlength, threads) {
    .Call('_WSGeometry_krbary_subgrad_cxx', PACKAGE = 'WSGeometry', weightsR, costMatsR, frechet_weights, maxIter, stepsize, thresh, headstart, headstartlength, threads)
}

maaipm_fixed_cpp <- function(p, s, x, b, costvec, constMat, N, m, M, sizes, sizescsum, nr, nc, U, maxIter, thresh, threads) {
    .Call('_WSGeometry_maaipm_fixed_cpp', PACKAGE = 'WSGeometry', p, s, x, b, costvec, constMat, N, m, M, sizes, sizescsum, nr, nc, U, maxIter, thresh, threads)
}

maaipm_free_cpp <- function(p, s, x, b, costvec, support, fullsupport, constMat, N, m, M, sizes, sizescsum, nr, nc, U, maxIter, outer_maxIter, thresh, threads) {
    .Call('_WSGeometry_maaipm_free_cpp', PACKAGE = 'WSGeometry', p, s, x, b, costvec, support, fullsupport, constMat, N, m, M, sizes, sizescsum, nr, nc, U, maxIter, outer_maxIter, thresh, threads)
}

transport_network_dual_arma <- function(a, b, C) {
    .Call('_WSGeometry_transport_network_dual_arma', PACKAGE = 'WSGeometry', a, b, C)
}

transport_network_primal_arma <- function(a, b, C) {
    .Call('_WSGeometry_transport_network_primal_arma', PACKAGE = 'WSGeometry', a, b, C)
}

#' Updating the segment node values in x < 0
#'
#' This function is used to calculate the step from e_{v,x} to t_{p,x} by subtracting
#' the edge weight from all segment node values in x < 0. If a segment passes through
#' x = 0, it is split in two parts and a new segment node is inserted in to the tree.
#'
#'
#' @param t A segment node.
#' @param k A numeric value. Typically, the distance from the leftmost element to 0.
#' @param c A numeric value. The value that is subtracted from all segment node slopes in x < 0.
#'      If any segment goes through x = 0, the segment is divided in two parts.
#' @return The first segment node in x < 0
#' @noRd
NULL

#' Calcualting the keys and length of all segments with length > 0 in the subtree
#'  of t
#'
#' @param t A node in a segment tree
#' @param keys A vector to store the keys
#' @param length A vector to store the keys
#' @return by reference: Key and length vectors
#' @noRd
NULL

#' Greedily calculate an optimal transport plan on a tree (matching marginals exactly). The transport
#' plan is not unique.
#' 
#' @param T the tree
#' @param a a vector containing (demand - supply) for every node (to be matched exactly)
#' @param tp (output) the transport plan constructed
#' @param v current vertex
#' @param p previously visited vertex
#' @return cost, amount of unmatched (demand - supply) in visited subgraph and a list of vertices 
#' visited vertices which are unsatisfied together with how much (demand - supply) they require
#'
#' @noRd
NULL

#' The tree metric unbalanced optimal transport algorithm
#'
#' This function makes the unbalanced optimal transport algorithm for tree metrics
#' accessible from R. It calculated the optimal transport cost and the import vector.
#'
#' @param tree A tree structure given in list form. Each entry in the list represents
#'          an edge: (first node, second node, edge weight)
#' @param supply The supply vector.
#' @param demand The demand vector.
#' @param creation A numeric vector giving the creation cost at each node.
#' @param destruction A numeric vector giving the destruction cost at each node.
#' @return A list containing the optimal transport cost and the import vector.
#' @noRd
treegkr_Rcpp <- function(tree, supply, demand, creation, destruction) {
    .Call('_WSGeometry_treegkr_Rcpp', PACKAGE = 'WSGeometry', tree, supply, demand, creation, destruction)
}

umaaipm_free_cpp <- function(p, s, x, b, costvec, support, fullsupport, constMat, N, m, M, sizes, sizescsum, nr, nc, U, C, maxIter, outer_maxIter, thresh, threads) {
    .Call('_WSGeometry_umaaipm_free_cpp', PACKAGE = 'WSGeometry', p, s, x, b, costvec, support, fullsupport, constMat, N, m, M, sizes, sizescsum, nr, nc, U, C, maxIter, outer_maxIter, thresh, threads)
}

umaaipm_fixed_cpp <- function(p, s, x, b, costvec, support, fullsupport, constMat, N, m, M, sizes, sizescsum, nr, nc, U, C, maxIter, thresh, threads) {
    .Call('_WSGeometry_umaaipm_fixed_cpp', PACKAGE = 'WSGeometry', p, s, x, b, costvec, support, fullsupport, constMat, N, m, M, sizes, sizescsum, nr, nc, U, C, maxIter, thresh, threads)
}

