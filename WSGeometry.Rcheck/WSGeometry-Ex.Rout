
R version 4.1.2 (2021-11-01) -- "Bird Hippie"
Copyright (C) 2021 The R Foundation for Statistical Computing
Platform: x86_64-w64-mingw32/x64 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "WSGeometry"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> options(pager = "console")
> base::assign(".ExTimings", "WSGeometry-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('WSGeometry')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("barycenter_lp")
> ### * barycenter_lp
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: barycenter_lp
> ### Title: Exact computation of 2-Wasserstein barycenters in R^d using
> ###   linear programming
> ### Aliases: barycenter_lp
> 
> ### ** Examples
> 
> pos.list<-vector("list",4)
> weights.list<-vector("list",4)
> pos.list[[1]]<-matrix(c(0,0,1,1,1,0,0,1),nrow=4,ncol=2)/10
> pos.list[[2]]<-matrix(c(9,9,10,10,10,9,9,10),nrow=4,ncol=2)/10
> pos.list[[3]]<-matrix(c(9,9,10,10,1,0,0,1),nrow=4,ncol=2)/10
> pos.list[[4]]<-matrix(c(0,0,1,1,10,9,9,10),nrow=4,ncol=2)/10
> plot(0, 0, xlab = "", ylab = "", type = "n", xlim = c(0, 1), ylim = c(0, 1))
> for(i in 1:4)
+   points(pos.list[[i]][,1], pos.list[[i]][,2], col = i)
> weights.list[[1]]<-rep(1/4,4)
> weights.list[[2]]<-rep(1/4,4)
> weights.list[[3]]<-rep(1/4,4)
> weights.list[[4]]<-rep(1/4,4)
> bary<-barycenter_lp(pos.list,weights.list)
> points(bary$positions[,1],bary$positions[,2], col = "orange", pch = 13)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("barycenter_lp", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("geodesic_pos")
> ### * geodesic_pos
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geodesic_pos
> ### Title: Compute Wasserstein geodesics
> ### Aliases: geodesic_pos
> 
> ### ** Examples
> 
> U<-runif(20)
> U<-U/sum(U)
> pos<-matrix(runif(2*20),nrow=20,ncol=2)
> P1<-transport::wpp(pos,U)
> U<-runif(20)
> U<-U/sum(U)
> pos<-matrix(runif(2*20),nrow=20,ncol=2)
> P2<-transport::wpp(pos,U)
> geodesic<-geodesic_pos(P1,P2,p=2,seq(0,1,0.1))
> ## Set the image and/or gif flags to TRUE to run the example. 
> ## CRAN policy prevents examples from generating files in the working directory,
> ## so this had to be disabled.
> plotGeodesic(geodesic,File="GeodesicR2",images=FALSE,gif=FALSE)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geodesic_pos", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("kr_bary")
> ### * kr_bary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kr_bary
> ### Title: Solves the (2,C)-Barycenter problem between N measures of
> ###   possibly unequal total mass on R^d.
> ### Aliases: kr_bary
> 
> ### ** Examples
> 
> #Generate a dataset consisting of measures supported on discretized nested ellipses.
> N<-5 #The number of measures generated
> M<-20 #The number of points each ellipse is discretized into
> C<-2 #The parameter of the Kantorovich-Rubinstein distance
> data.list<-vector("list",N)
> set.seed(42)
> nest.vec<-rep(0,N) #A vector containing the number of ellipses in the data measures.
> max.ell<-3 #The maximum number of ellipses in each measure. The number is chosen
> #uniformly between 1 and this value.
> #This loop actually generates the measures for the example.
> for (i in 1:N){
+   pos.full<-matrix(0,0,2)
+   nesting.depth<-ceiling(runif(1,0,max.ell))
+   nest.vec[i]<-nesting.depth
+   for (k in 1:nesting.depth){
+     t.vec<-seq(0,2*pi,length.out=M)
+     pos<-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))/(3^(k-1)) 
+     theta<-runif(1,0,2*pi)
+     rotation<-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
+     pos.full<-rbind(pos.full,pos%*%rotation)
+   }
+   W<-rep(1,M*nesting.depth)
+   data.list[[i]]<-transport::wpp((pos.full+1)/2,W)
+ }
> #Using the multiscale method
> system.time(bary.ms<-WSGeometry::kr_bary(data.list,C,method="multiscale",
+ support=c(8,8,3,10^-2),wmaxIter=100,return_type="mat",thresh=6*10^-4,threads=1))
   user  system elapsed 
   1.20    0.04    1.25 
> #Using the fixed support method
> support<-t(WSGeometry::grid_positions(20,20))
> system.time(bary.fixed<-WSGeometry::kr_bary(data.list,C,method="fixed",
+ support=support,wmaxIter=100,return_type="wpp",thresh=6*10^-4,threads=1))
   user  system elapsed 
   5.01    0.14    5.17 
> #Using the free support method
> support<-t(WSGeometry::grid_positions(8,8))
> system.time(bary.free<-WSGeometry::kr_bary(data.list,C,method="free",
+ support=support,wmaxIter=100,pmaxIter=25,return_type="wpp",thresh=8*10^-4,threads=1))
   user  system elapsed 
   1.22    0.36    1.61 
> 
> #The outputs can be conveniently visualised using the image function for the "mat" output
> #and the plot-method for the wpp-objects provided by the transport package.
> image(bary.ms)
> plot(bary.fixed)
> plot(bary.free)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kr_bary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("kr_dist")
> ### * kr_dist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: kr_dist
> ### Title: Compute the p-Kantorovich-Rubinstein distance between two
> ###   measures of possibly unequal total mass.
> ### Aliases: kr_dist
> 
> ### ** Examples
> 
> M<-1000
> W1<-runif(M)
> W2<-runif(M)
> pos1<-matrix(runif(M*2),M,2)
> pos2<-matrix(runif(M*2),M,2)
> wpp1<-transport::wpp(pos1,W1)
> wpp2<-transport::wpp(pos2,W2)
> system.time(res<-WSGeometry:::kr_dist(wpp1,wpp2,2,2))
   user  system elapsed 
   0.15    0.07    0.22 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("kr_dist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("location_scatter_bary")
> ### * location_scatter_bary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: location_scatter_bary
> ### Title: Computes the 2-Wasserstein barycenter of location-scatter
> ###   families of measures
> ### Aliases: location_scatter_bary
> 
> ### ** Examples
> 
> #One dimensional example
> mean.list<-list(5,15)
> var.list<-list(1,4)
> res<-location_scatter_bary(mean.list,var.list)
> x<-seq(0,22,10^-4)
> y1<-dnorm(x,mean=5,sd=1)
> y2<-dnorm(x,mean=15,sd=2)
> y3<-dnorm(x,mean=res$mean,sd=sqrt(res$cov))
> plot(x,y1,type="l",main = "Barycenter of two 1-d Gaussian distributions",
+ ylab = "density",col="blue")
> lines(x,y2,col="green")
> lines(x,y3,col="red")
> legend(15,0.4, legend=c("N(5,1)", "N(15,4)","Barycenter"),
+        col=c("blue","green","red"),lty=1,cex=0.9)
>        
>        
> #two dimensional example
> # packages graphics and mvtnorm are required to run this example
> set.seed(2898581)
> mean.list <- list(c(0,0), c(0,0), c(0,0))
> COV <- 0.3 + rWishart(3, df = 2, Sigma = diag(2))
> cov.list <- list(COV[,, 1], COV[,, 2], COV[,, 3])
> res<-location_scatter_bary(mean.list, cov.list)
> 
> x <- y <- seq(-3, 3, .1)
> z <- array(0.0, dim = c(length(x), length(y), 4))
> for(i in seq_along(x))
+  for(j in seq_along(y))
+  {
+    for(n in 1:3)
+      z[i, j, n] <- mvtnorm::dmvnorm(c(x[i], y[j]), sigma = COV[, , n])
+    
+    z[i, j, 4] <- mvtnorm::dmvnorm(c(x[i], y[j]), sigma = res$cov)
+  }
> 
> op <- par(mfrow = c(2, 2),  mai = c(0, 0, 0, 0))
> for(n in 1:3)
+ {
+  graphics::persp(x, y, z[, , n], theta = 30, phi = 30, expand = 0.5, col = "lightblue",
+   zlab = "", ticktype = "detailed", shade = .75, lphi = 45, ltheta = 135)
+  text(x = 0, y = 0.2, labels = paste("COV[,, ", n, "]", sep = ""))
+ }
> 
> graphics::persp(x, y, z[, , 4], theta = 30, phi = 30, expand = 0.5, col = "red", zlab = "",
+ ticktype = "detailed", shade = .75, lphi = 45, ltheta = 135)
> text(x = 0, y = 0.2, labels = "barycenter")
> par(op)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("location_scatter_bary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("multi_marginal")
> ### * multi_marginal
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: multi_marginal
> ### Title: Solve the multimarginal optimal transport problem by linear
> ###   programming
> ### Aliases: multi_marginal
> 
> ### ** Examples
> 
> W<-list(rep(1,10),rep(1,10),rep(1,10))
> C<-array(runif(10^3),c(10,10,10))
> MM<-multi_marginal(W,C)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("multi_marginal", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plotGeodesic")
> ### * plotGeodesic
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plotGeodesic
> ### Title: Plot previously computed Wasserstein geodesics
> ### Aliases: plotGeodesic
> 
> ### ** Examples
> 
> #2D-Example:
> library(transport)
> set.seed(420)
> N<-2
> supp.size<-10^2
> L<-sqrt(supp.size)
> d<-2
> data.list<-vector("list",N)
> image.list<-vector("list",N)
> for (i in 1:N){
+   t.vec<-seq(0,2*pi,length.out=supp.size)
+   pos<-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))
+   theta<-runif(1,0,2*pi)
+   rotation<-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
+   pos<-pos%*%rotation
+   pos<-pos+1
+   pos<-pos/2
+   W<-rep(1/supp.size,supp.size)
+   data.list[[i]]<-transport::wpp(pos,W)
+ }
> Geo<-geodesic_pos(data.list[[1]],data.list[[2]],2,seq(0,1,0.1))
> ## Set the image and/or gif flags to TRUE to run the example. 
> ## CRAN policy prevents examples from generating files in the working directory,
> ## so this had to be disabled.
> plotGeodesic(Geo,File="TestGeodesicDefault",images=FALSE,gif=FALSE)
> plotGeodesic(Geo,method="bin",File="TestGeodesicDefaultBin",images=FALSE,gif=FALSE)
> plotGeodesic(Geo,method="binSplit",File="TestGeodesicDefaultBinSPlit",
+ images=FALSE,gif=FALSE)
> ## No test: 
> #3D-Example:
> #Functions to build the example measures
> gen_torus<-function(M,R,r){
+  theta<-seq(0,2*pi,length.out=M)
+  phi<-seq(0,2*pi,length.out=M)
+  G<-expand.grid(theta,phi)
+  x<-(R+r*cos(G[,1]))*cos(G[,2])
+  y<-(R+r*cos(G[,1]))*sin(G[,2])
+  z<-r*sin(G[,1])
+  return(cbind(x,y,z))
+ }
> sq_norm<-function(v){
+  return(sqrt(sum(v^2)))
+ }
> normalize<-function(v){
+  return(v/(sq_norm(v)))
+ }
> rotate3D<-function(pos,axis,angle){
+  R<-matrix(0,3,3)
+  R[1]<-cos(angle)+axis[1]^2*(1-cos(angle))
+  R[2]<-axis[1]*axis[2]*(1-cos(angle))+axis[3]*sin(angle)
+  R[3]<-axis[3]*axis[1]*(1-cos(angle))-axis[2]*sin(angle)
+  R[4]<-axis[1]*axis[2]*(1-cos(angle))-axis[3]*sin(angle)
+  R[5]<-cos(angle)+axis[2]^2*(1-cos(angle))
+  R[6]<-axis[2]*axis[3]*(1-cos(angle))+axis[1]*sin(angle)
+  R[7]<-axis[1]*axis[3]*(1-cos(angle))+axis[2]*sin(angle)
+  R[8]<-axis[2]*axis[2]*(1-cos(angle))-axis[1]*sin(angle)
+  R[9]<-cos(angle)+axis[3]^2*(1-cos(angle))
+  return(t(diag(c(2,3,1))%*%(R%*%t(pos))))
+ }
> ## Example
> set.seed(123)
> M<-40
> U<-runif(1,0.5,1)
> Torus<-gen_torus(M,U,min(U/2,runif(1)))
> v<-normalize(runif(3))
> Torus<-rotate3D(Torus,v,runif(1,0,2*pi))
> Torus1<-Torus%*%diag(runif(3,1,3))
> U<-runif(1,0.5,1)
> Torus<-gen_torus(M,U,min(U/2,runif(1)))
> v<-normalize(runif(3))
> Torus<-rotate3D(Torus,v,runif(1,0,2*pi))
> Torus2<-Torus%*%diag(runif(3,1,3))
> L<-length(Torus)/3
> Torus1<-transport::wpp(Torus1,rep(1/L,L))
> Torus2<-transport::wpp(Torus2,rep(1/L,L))
> geo<-geodesic_pos(Torus1,Torus2,p=2,seq(0,1,0.1))
> ## Set the image and/or gif flags to TRUE to run the example. 
> ## CRAN policy prevents examples from generating files in the working directory,
> ## so this had to be disabled.
> plotGeodesic(geo,File="3dGeodesic",images=FALSE,gif=FALSE)
> ## End(No test)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plotGeodesic", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching 'package:transport'

> nameEx("wasserstein_bary")
> ### * wasserstein_bary
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: wasserstein_bary
> ### Title: Compute Wasserstein barycenters
> ### Aliases: wasserstein_bary
> 
> ### ** Examples
> 
> ##Basic Examples
> #build list
> K<-1
> N<-4*K
> M<-9
> d<-2
> data.list<-vector("list",N)
> 
> ###image_mat
> for (i in 1:K){
+   U<-runif(M)
+   U<-U/sum(U)
+   data.list[[i]]<-matrix(U,sqrt(M))
+ }
> 
> #wpp
> for (i in (K+1):(2*K)){
+   U<-runif(M)
+   U<-U/sum(U)
+   pos<-matrix(runif(d*M),M,d)
+   data.list[[i]]<-transport::wpp(pos,U)
+ }
> 
> #point pattern
> for (i in (2*K+1):(3*K)){
+   pos<-matrix(runif(d*M),M,d)
+   data.list[[i]]<-list(positions=pos)
+ }
> 
> #weighted point pattern
> 
> for (i in (3*K+1):(4*K)){
+   U<-runif(M)
+   U<-U/sum(U)
+   pos<-matrix(runif(d*M),M,d)
+   data.list[[i]]<-list(positions=pos,weights=U)
+ }
> 
> system.time(res1<-wasserstein_bary(data.list,return_type = "wpp",method="lp"))
   user  system elapsed 
   0.18    0.01    0.19 
> frechet_func(res1,data.list)
[1] 0.04609785
> ## No test: 
> system.time(res2<-wasserstein_bary(data.list,return_type = "wpp",method="alternating",
+ supp.size = M*N-N+1,warmstartlength = 3,pos_maxIter = 100,weights_maxIter = 100))
   user  system elapsed 
   1.27    1.24    2.51 
> frechet_func(res2,data.list)
[1] 0.04703198
> ## End(No test)
> system.time(res3<-wasserstein_bary(data.list,return_type = "wpp",
+ method="fixed_support",warmstartlength = 3,weights_maxIter = 100,output.supp = res1$coordinates))
   user  system elapsed 
   0.66    0.65    1.31 
> frechet_func(res3,data.list)
[1] 0.04640091
> system.time(res4<-wasserstein_bary(data.list,return_type = "wpp",
+ method="sampling",sample.size=8,warmstartlength = 3,pos_maxIter = 100))
   user  system elapsed 
   0.00    0.07    0.06 
> frechet_func(res4,data.list)
[1] 0.05962321
> ## No test: 
> ##Visual Examples
> ###ellipses
> set.seed(420)
> N<-20
> supp.size<-10^2
> L<-sqrt(supp.size)
> d<-2
> data.list<-vector("list",N)
> image.list<-vector("list",N)
> for (i in 1:N){
+   t.vec<-seq(0,2*pi,length.out=supp.size)
+   pos<-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))
+   theta<-runif(1,0,2*pi)
+   rotation<-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
+   pos<-pos%*%rotation
+   pos<-pos+1
+   pos<-pos/2
+   W<-rep(1/supp.size,supp.size)
+   data.list[[i]]<-transport::wpp(pos,W)
+   I<-bin2d(data.list[[i]]$coordinates,data.list[[i]]$mass,c(L*2,L*2))
+   I<-smear(I,1,1)
+   I<-I/sum(I)
+   image.list[[i]]<-I
+ }
> 
> system.time(res1<-wasserstein_bary(data.list,return_type = "wpp",method="alternating"
+ ,supp.size = supp.size,warmstartlength = 0,pos_maxIter = 10,weights_maxIter = 10,maxIter = 10))
   user  system elapsed 
  11.00    8.59   19.67 
> plot(res1)
> system.time(res2<-wasserstein_bary(data.list,return_type = "wpp",
+ method="fixed_support",warmstartlength = 0,weights_maxIter = 50,maxIter=1,
+ output.supp = grid_positions(2*L,2*L)))
   user  system elapsed 
   8.52    6.31   14.84 
> plot(res2)
> system.time(res3<-wasserstein_bary(data.list,return_type = "wpp",method="sampling",
+ sample.size=400,warmstartlength = 0,pos_maxIter = 100,stepsize = 1,maxIter=1))
   user  system elapsed 
   0.61    0.58    1.18 
> plot(res3)
> 
> system.time(res4<-wasserstein_bary(image.list,return_type = "wpp",
+ method="regular",stepsize = 1,weights_maxIter = 50))
   user  system elapsed 
   0.27    0.02    0.28 
> plot(res4)
> system.time(res5<-wasserstein_bary(image.list,return_type = "wpp",
+ method="fixed_support",shared=TRUE,warmstartlength = 0,weights_maxIter = 50,maxIter=1,
+ output.supp = grid_positions(2*L,2*L)))
   user  system elapsed 
  19.08   11.61   30.72 
> plot(res5)
> ## End(No test)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("wasserstein_bary", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ws_bary_maaipm")
> ### * ws_bary_maaipm
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ws_bary_maaipm
> ### Title: Solves the 2-Wasserstein Barycenter problem between N
> ###   probability measures on R^d using an interior point method.
> ### Aliases: ws_bary_maaipm
> 
> ### ** Examples
> 
> #Generate a dataset consisting of measures supported on discretized nested ellipses.
> N<-5 #The number of measures generated
> M<-20 #The number of points each ellipse is discretized into
> C<-2 #The parameter of the Kantorovich-Rubinstein distance
> data.list<-vector("list",N)
> set.seed(42)
> ell.num<-3 #The  number of ellipses in each measure.
> #This loop actually generates the measures for the example.
> for (i in 1:N){
+   pos.full<-matrix(0,0,2)
+   nesting.depth<-ell.num
+   for (k in 1:nesting.depth){
+     t.vec<-seq(0,2*pi,length.out=M)
+     pos<-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))/(3^(k-1)) 
+     theta<-runif(1,0,2*pi)
+     rotation<-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
+     pos.full<-rbind(pos.full,pos%*%rotation)
+   }
+   W<-rep(1,M*nesting.depth)
+   W<-W/sum(W)
+   data.list[[i]]<-transport::wpp((pos.full+1)/2,W)
+ }
> #Using the multiscale method
> system.time(bary.ms<-WSGeometry::ws_bary_maaipm(data.list,method="multiscale",
+ support=c(8,8,3,10^-4),wmaxIter=100,return_type="mat",thresh=6*10^-4,threads=1))
   user  system elapsed 
   1.04    0.07    1.13 
> #Using the fixed support method
> support<-t(WSGeometry::grid_positions(20,20))
> system.time(bary.fixed<-WSGeometry::ws_bary_maaipm(data.list,method="fixed",
+ support=support,wmaxIter=100,return_type="wpp",thresh=6*10^-4,threads=1))
   user  system elapsed 
   2.42    0.08    2.50 
> #Using the free support method
> support<-t(WSGeometry::grid_positions(8,8))
> system.time(bary.free<-WSGeometry::ws_bary_maaipm(data.list,method="free",
+ support=support,wmaxIter=100,pmaxIter=25,return_type="wpp",thresh=6*10^-4,threads=1))
   user  system elapsed 
   1.19    0.06    1.25 
> 
> #The outputs can be conveniently visualised using the image function for the "mat" output
> #and the plot-method for the wpp-objects provided by the transport package.
> image(bary.ms)
> plot(bary.fixed)
> plot(bary.free)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ws_bary_maaipm", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ws_dist")
> ### * ws_dist
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ws_dist
> ### Title: Compute the p-Wasserstein distance between two measures
> ### Aliases: ws_dist
> 
> ### ** Examples
> 
> P1<-transport::random32a$mass
> P2<-transport::random32b$mass
> P1<-P1/sum(P1)
> P2<-P2/sum(P2)
> ws_dist(P1,P2)
[1] 0.1020387
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ws_dist", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("ws_logpca")
> ### * ws_logpca
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: ws_logpca
> ### Title: Computes Wasserstein principal components
> ### Aliases: ws_logpca
> 
> ### ** Examples
> 
> set.seed(2020)
> N<-20
> supp.size<-10^2
> L<-sqrt(supp.size)
> d<-2
> data.list<-vector("list",N)
> image.list<-vector("list",N)
> for (i in 1:N){
+   t.vec<-seq(0,2*pi,length.out=supp.size)
+   pos<-cbind(cos(t.vec)*runif(1,0.2,1),sin(t.vec)*runif(1,0.2,1))
+   theta<-runif(1,0,2*pi)
+   rotation<-matrix(c(cos(theta),sin(theta),-1*sin(theta),cos(theta)),2,2)
+   pos<-pos%*%rotation
+   pos<-pos+1
+   pos<-pos/2
+   W<-rep(1/supp.size,supp.size)
+   data.list[[i]]<-transport::wpp(pos,W)
+ }
> 
> res1<-wasserstein_bary(data.list,return_type = "wpp",method="alternating",
+ supp.size = supp.size,warmstartlength = 2,pos_maxIter = 50,
+ weights_maxIter = 0,maxIter = 1,stepsize=1)
> pcomps<-ws_logpca(data.list,res1,3)
> ## Set the image and/or gif flags to TRUE to run the example. 
> ## CRAN policy prevents examples from generating files in the working directory,
> ## so this had to be disabled.
> plotGeodesic(pcomps$components[[1]],File="PCA1",images=FALSE,gif=FALSE)
> plotGeodesic(pcomps$components[[2]],File="PCA2",images=FALSE,gif=FALSE)
> plotGeodesic(pcomps$components[[3]],File="PCA3",images=FALSE,gif=FALSE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("ws_logpca", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  58.77 30.76 89.72 NA NA 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
